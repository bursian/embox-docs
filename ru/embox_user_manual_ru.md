---
title: "Embox - Быстрый старт"
author: "Антон Бондарев"
date: "20 января 2019"
header-includes:
   - \usepackage[russian]{babel}

---

# Краткое описание
Embox — операционная система реального времени, ориентированная на применение во встроенных системах.

Embox является кросс-платформенной ОС, архитектурно-зависимые части вынесены в отдельные модули, что упрощает процесс портирования на новые платформы. Embox поддерживает следующие процессорные архитектуры: x86, ARM, MIPS, SPARC, PPC,  Microblaze, E2k.

Embox является многозадачной ОС и поддерживает различные уровни приоритета задач, вытесняющую многозадачность, защиту от инверсии приоритета и различные способы синхронизации.

Embox предоставляет слой POSIX-совместимости, который позволяет использовать большое количество готового ПО разработанного под Linux. Примерами являются библиотека Qt, клиент и сервер SSH — Dropbear, проект по созданию SIP-телефонов на основе пополярной библиотеки PJSIP.

Embox позволяет сохранить разработку привычной и удобной на всех платформах, в том числе на платформах с ограниченными ресурсами, такими как микроконтроллеры. Так как используются стандартные средства разработки, а стандартная библиотека языка С конфигурируется вместе с образом.

Embox имеет низкие требования к ресурсам, поскольку построен на принципах модульности и конфигурируемости. При конфигурации системы можно выбрать, какие модули будут включены в образ. Таким образом, достигается создание образа, нацеленного на конкретную задачу, будь то система для тестирования аппаратного обеспечения, или полноценная система с множеством приложений и богатой функциональностью.

Embox позволяет создавать более безопасные системы. Основным является статическая конфигурация системы, при которой гарантируется, что невозможно выполнить приложения не включенные в конечный образ.

Embox хорошо подходит для устройств интернета вещей (IoT). Поскольку имеет развитый сетевой стек и богатый набор прикладных приложений и библиотек, но вместе с тем имеет низкие требования к аппаратным ресурсам.

Embox хорошо подходит для робототехники, поскольку позволяет совмещать в одной системе, задачи требующие сложные функциональные возможности и задачи “реального времени”.

# Быстрый старт
Ознакомление с Embox лучше начать с запуска на эмуляторе qemu поддерживающего различные процессорные архитектуры.

## Получение кода Embox
Клонируем мастер:
```
    $ git clone https://github.com/embox/embox
```
Либо скачиваем архивом из [https://github.com/embox/embox/releases](https://github.com/embox/embox/releases)
 
## Работа в Windows  и MacOS
Все описания сделаны для Linux. Для сборки и работы под Windows и MacOS лучше использовать Docker в котором уже настроено все необходимое окружение для начальной работы.
Для этого:
 * Установите docker для вашей ОС.

 * Убедитесь, что docker установлен правильно с помощью команд:
```
    $ docker-machine ls
    $ docker-machine start default
```

 * Перейдите в консоли в корневую папку с исходниками Embox.

 * Запустите докер выполнив скрипт
```
    $ ./scripts/docker/docker_start.sh
```

 * Для упрощения работы выполните скрипт командой
```
    $. ./scripts/docker/docker_rc.sh
```
   Данный скрипт позволит писать команду `dr` вместо `docker run`

Далее перед каждой командой необходимо вставлять `dr`. Например,
```
    $ dr make confload-x86/qemu
    $ dr make
    $ dr ./scripts/qemu/auto_qemu
```
Для конфигурации сборки и запуска базового темплейта.

После установки и проверки работоспособности, можно пропустить раздел настройка окружения и перейти сразу к разделу “Сборка и запуск на QEMU”

## Настройка окружения
Необходимые пакеты: make, gcc (кросс-компилятор под выбранную архитектуру,  см. “Установка кросс-компилятора”).
Дополнительные пакеты (рекомендуется установить сразу): build-essential gcc-multilib curl libmpc-dev python
Пример установки для Debian:
```
    $ sudo apt-get install make gcc \
        build-essential gcc-multilib \
        curl libmpc-dev python
```
Пример установка для Arch:
```
    $ sudo pacman -S make gcc-multilib cpio qemu
```

## Установка кросс-компилятора 
x86:
```
     $ sudo apt-get install gcc
```
Обычно уже установленный пакет. Вам потребуется другой компилятор, если Вы настраиваете окружение самостоятельно для Windows или MacOS.
ARM:
```
     $ sudo apt install arm-none-eabi-gcc
```
Или для Debian
```
    $ sudo apt install gcc-arm-none-eabi
```
Либо скачать архив с тулчейном с сайта https://launchpad.net/gcc-arm-embedded
    Распаковать архив и сделать export тулчейна:
```
   $ export PATH=$PATH:<путь к тулчейну>/gcc-arm-none-eabi-<version>/bin
```

SPARC, Microblaze, MIPS, PowerPC, MSP430:
Для этих архитектур можно воспользоваться нашим проектом по сборке crosstool [https://github.com/embox/crosstool](https://github.com/embox/crosstool)
Можно скачать последнюю версию уже собранного архива в требуемым кросс-компилятором отсюда [https://github.com/embox/crosstool/releases](https://github.com/embox/crosstool/releases)
Или собрать его выкачав скрипты из репозитория с помощью команды 
```
    $ ./crosstool.sh ARCH
```
После этого должен появиться архив с тулчейном — ARCH-elf-toolchain.tar.bz2. Далее, его нужно распаковать и добавить в переменную окружения PATH как показано выше для ARM.

## Установка эмулятора QEMU
Поддерживаемые архитектуры: x86, ARM, MIPS, Sparc, PPC, Microblaze.

Необходимые пакеты: qemu (под выбранную архитектуру)
```
    $ sudo apt-get install qemu-system-<ARCH> 
```
где <ARCH> это i386, arm, sparc, mips, ppc или misc (для microblaze)
Примечание: Все пакеты qemu можно установить единым пакетом — 
```
    $ sudo apt-get install qemu-system
```


## Сборка и запуск на QEMU
Загружаем конфигурацию по умолчанию для выбранной архитектуры:
```
   $ make confload-<ARCH>/qemu
```
, где ARCH: x86, arm, mips, ppc, sparc, microblaze.
Пример под x86:
```
    $ make confload-x86/qemu
```
Собираем Embox:
```
    $ make
```
или запускем параллельную сборку:
```
    $ make (-jN)
```
Пример:
```
    $ make -j4
```
Запускаем:
```
    $ ./scripts/qemu/auto_qemu
```

Пример вывода в консоль:
```
Embox kernel start
    unit: initializing embox.kernel.task.task_resource: done
    unit: initializing embox.mem.vmem_alloc: done
```
Если все unit тесты прошли успешно и система загружена, появиться консоль в которой можно выполнять команды. Начать можно с команды help которая выведет список доступных команд для вашей конфигурации.
Для выхода нажмите последовательно ***ctrl+’A’*** затем ***‘x’***.

# Особенности системы сборки Mybuild
Embox - модульная и конфигурируемая система. Для этих целей был разработан декларативный язык описания Mybuild. Он позволяет описывать как отдельные единицы системы (модули) так и всю систему в целом.
Модуль является базовым понятием для системы сборки. Он содержит список файлов относящихся к данному модулю, параметры которые можно задать модулю в момент конфигурации и список зависимостей.
 Конфигурация является детализированным описанием желаемой системы. Включает в себя список модулей необходимых для сборки, параметры модулей и описания правил сборки (компилятор, флаги компилятора, карта памяти устройства, и так далее). На основе конфигурации и описания модулей строится граф с параметрами системы и по нему генерируются различные файлы для сборки: линкер скрипты, makefile ы, заголовочные файлы. В конфигурации не обязательно указывать все необходимые модули, они подтягиваются по зависимостям из описания модулей.
Текущая конфигурация располагается в папке *conf/*. Может быть выбрана с помощью команды ***make confload-<CONF_NAME>***. Например, для задания демонстрационной конфигурации для запуска на qemu-arm необходимо выполнить ***$ make confload-arm/qemu***. Для просмотра готовых конфигураций можно выполнить ***make confload***. После задания текущей конфигурации можно изменять файлы под свои требования. Например, чтобы добавить какое нибудь приложение которого нет в текущей конфигурации достаточно добавить в файл conf/mods.conf строку ***include <PACKAGE_NAME><MODULE_NAME>***. Пример, для добавления в конфигурацию команды *`help`* нужно добавить строчку ***include embox.cmd.help***

# Создание и запуск “hello world”
Приложение в Embox представляет собой модуль в описании которого содержаться атрибуты указывающие, что это приложение можно запускать из командной строки. Исходный код представляет собой обычное приложение которое можно скомпилировать с том числе и в Linux окружении.

## Создание и запуск примера
Разберем простейшее приложение *“hello world”*
Создадим папку *hello_world* в src/cmds
```
    $ mkdir src/cmds/hello_world
```
Создадим файл с исходным кодом приложения ***src/cmds/hello_world/hello_world.c*** со следующим содержанием:
```
#include <stdio.h>

int main(int argc, char **argv) {
	printf("Hello, world!\\n");
}
```

Создадим файл описания модуля `src/cmds/hello_world/Mybuild’ следующего содержания:
```
package embox.cmd

@AutoCmd
@Cmd(name = "hello_world", help=” first Embox application”)
module hello_world {
	source "hello_world.c"
}
```
Добавим в файл конфигурации системы conf/mods.conf строчку с подключением нового модуля
```
include embox.cmd.hello_world
```
Скомпилируем 
```
 $ make
```
Запустим 
```
 $ ./scripts/qemu/auto_qemu
```
В появившейся консоли убедимся, что если набрать команду ***help*** то в списке будет новая команда. Выполним команду набрав ее в консоли ***hello_world***
Должно появиться наше сообщение выведенное с помощью функции *printf*
```
root@embox:/#hello_world 
Hello, world!
root@embox:/#
```

## Файл описания модуля
Разберем немного подробнее файл описания модуля
```
package embox.cmd

@AutoCmd
@Cmd(name = "hello_world", help=” first Embox application”)
module hello_world {
	source "hello_world.c"
}
```
В первой строке идет указание имени пакета *package embox.cmd*. В Embox все модули распределены по пакетам, для удобства именования. Полное имя модуля будет состоять из имени пакета и имени модуля. Имя модуля в нашем случае находиться в строке *module hello_world *.

Строка *source "hello_world.c"* указывает файлы с исходным кодом необходимые для корректной сборки модуля.

В строке *@Cmd(name = "hello_world", help=”First Embox application”)* задается атрибут для модуля. Во первых модуль будет представлять из себя приложение, во вторых задает имя с помощью которого это приложение можно вызвать. И наконец, задается строка, которая будет отображаться для этого приложения при вызове команды *‘help’*.

# Система сборки Mybuild
Mybuild - это система автоматизации сборки и конфигурирования для модульных приложений.

Mybuild реализован поверх [GNU Make](http://www.gnu.org/software/make/), тем самым поддерживая все возможности инкрементальной и параллельной сборки последнего. Кроме того, это позволяет встроить Mybuild в уже существующую инфраструктуру сборки, использующую Make.
В то же время, несмотря на использование Make, Mybuild использует собственный синтаксис, лишенный недостатков языка Makefile'ов.

## Процесс разработки

Типичный сценарий разработки проекта, использующего Mybuild, включает две группы людей:

|            Разработчики                                 |    Пользователи                      |
|         ------------------------------------------      |   ---------------------------------  |
| которые поддерживают файлы для сборки разрабатываемых ими компонентов.|  которым требуется просто собрать проект (возможно, в различных конфигурациях). |

_В действительности, есть еще разработчики самого Mybuild, но их мы пока что не рассматриваем._
Таким образом, существует два типа файлов для сборки: My-файлы и Config-файлы

### My-файлы
My-файлы используются для описания всех модулей приложения, доступных для сборки, их отношения между собой, а также параметры конфигурации.
Эти файлы пишутся разработчиками самого приложения и обычно располагаются в дереве файлов с исходным кодом.
``` 
module HelloWorld {
   source "hello.c"
}
```
 My-файлы именуются *`Mybuild`* либо *`*.my`*.
 
### Config-файлы
Config-файлы содержат указания для сборки определенных модулей и конкретные значения параметров конфигурации.
Предполагается, что данные файлы составляются пользователями, тем не менее, разработчики могут предоставить шаблоны для типичных конфигураций.
```
configuration Main {
    include HelloWorld
}
```
Конфигурационные файлы имеют расширение *`.config`*.

Оба типа файлов являются обычными текстовыми файлами (не XML!), которые можно редактировать в любом текстовом редакторе.

После того как необходимые my- и config-файлы готовы, проект можно собрать командой `make`.
На основе предоставленных сборочных файлов Mybuild решит, что именно и в каком порядке необходимо собрать. 

В заключение, процесс сборки можно представить следующим образом:
![](images/mybuild/mybuild-workflow.png)

## Mybuild процесс сборки
Процесс сборки с помощью системы Mybuild можно представить следующим образом:
![](images/mybuild/mybuild-build_sequence.png)

### Подготовка скриптов
Mybuild написана на расширении языка Make, поэтому, сначала требуется преобразовать код написанный на расширении языка Make в классические Make-файлы. Для ускорения этой процедуры используется кэширование: преобразуются только измененные с предыдущего запуска файлы. 

На этом этапе происходит проверка актуальности кэша исходных файлов Mybuild и библиотеки расширения. Если файл с исходным кодом не изменялся, используется его закэшированная версия. Иначе файл загружается, преобразуется и кэшируется с помощью скрипта.

### Создание графа описания модулей
Обработка Mybuild файлов (файлов описание модулей) разбивается на фазы:
![](images/mybuild/mybuild-graph_creation.png)

 * Нахождение Myfile в дереве с исходным кодом.
 * Для каждого файла:
    + Чтение файла.
    + Синтаксический разбор, создание объекта (mk/mybuild/myfile-model.mk) на каждую разобранную синтаксическую конструкцию.
    + Сохранение полученной после разбора модели файла для использования последующими стадиями (путь по умолчанию: mk/.cache/mybuild/files/).
 * Создание набора моделей, представляющего полное описание графа модулей, разрешение ссылок между моделями в наборе.
 * Проведение различных проверок, относящихся к графу модулей (соответствие типов опций и инициализирующих их значений, циклическое наследование, и т.д)
 * Кэширование полученного набора моделей.

### Создание модели системы
Для описания модели системы так же используется специализированный язык описания. Поэтому, для обработки файлов конфигурации проводятся фазы, аналогичные фазам 1-5 обработки файлов описания модулей. Затем, происходит создание Build-модели (mk/mybuild/build-model.mk), в нее входит модули, их файлы, опции модулей, опции компиляции. Для этого используются модели конфигурации и Mybuild.

![](images/mybuild/mybuild-model_creation.png)

### Генерация необходимых ресурсов
На этом этапе проводится сборка полученной на предыдущем этапе Build-модели.

 * Генерируется исходник на языке Си, содержащий run-time представление Build-модели.
 * Для модулей генерируются заголовочные файлы с опциями и экспортированными из модуля заголовочными файлами.
 * Для файлов с исходным кодом генерируются командные файлы, содержащие параметры командной строки компилятора.
 * Генерируется Make-правила для сборки целевого образа и промежуточных объектных файлов.

### Запуск скриптов на исполнение
На этой стадии сборки происходит передача управления от Mybuild к сгенерированному им скриптам сборки Make. Результатом выполнения данного этапа является полностью собранный образ целевой системы.

## Mybuild - внутренняя структура
Система сборки целиком написана на языке GNU Make и состоит из набора скриптов. Следует различать три основных типа Makefile’ов, используемых для реализации:
 * Классические Makefile’ы, в которых задаются правила для выполнения тех или иных целей, их зависимости и т.д. В основном к ним относятся скрипты верхнего уровня, определяющие последовательность запуска остальных скриптов.
 * Библиотеки функций, в которых определяются функции и классы. Большая часть логики Mybuild реализована именно в таких скриптах. Основная часть кода (за исключением сравнительно небольшого блока раскрутки), написана с использованием расширенного синтаксиса языка Make.
 * Скрипты, результатом выполнения которых является текстовый файл.

### Классические Makefile’ы
Для выполнения любой внешней цели (которую вызывает пользователь) сперва читается корневой Makefile. Его можно рассматривать как обертку для запуска самой системы сборки. В этом скрипте происходит проверка версии Make и необходимых флагов, задаются значения по умолчанию для директорий сборки и т.д. Далее управление передается в mk/main.mk.
mk/main.mk


Этот скрипт - фасад системы. В нем определяются все доступные для выполнения цели, а также документация для этих целей, которую можно увидеть, выполнив “make help” или “make help-'<'goal'>'”. Можно различать два вида целей:
Цели, которые можно выполнить “на месте” (загрузка конфигурации, clean, вывод справки по целям и т.п.).
Цели, для выполнения которых требуется чтение всех my-файлов и построения модели сборки (собственно, сборка проекта). В этом случае управление передается специальному загрузочному скрипту mk/load.mk
mk/load.mk


Скрипт используется для раскрутки остальных скриптов системы сборки, загрузки my-файлов и создания модели сборки. Разделен на два файла:
 - load-mk.inc.mk, который занимается раскруткой скриптов (библиотеки функций),
 - load-mybuild.inc.mk, который вызывает скрипты для разбора my-файлов, их линковки, сериализации и построения модели сборки.

![](images/mybuild/mybuild_classic_makefile.png)
